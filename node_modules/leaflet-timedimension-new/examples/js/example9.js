var map = L.map('map', {
    zoom: 12,
    fullscreenControl: true,
    center: [27.7172, 85.324]
});

// start of TimeDimension manual instantiation
var timeDimension = new L.TimeDimension({
        period: "PT1S",
    });
// helper to share the timeDimension object between all layers
map.timeDimension = timeDimension; 
// otherwise you have to set the 'timeDimension' option on all layers.

var player        = new L.TimeDimension.Player({
    loop: false,
    startOver:true,
    buffer: 1
}, timeDimension);

var timeDimensionControlOptions = {
    player: player,
      timeDimension: timeDimension,
      position: 'bottomleft',
      autoPlay: true,
      minSpeed: 1,
      speedStep: 1,
      maxSpeed: 15,
      timeSliderDragUpdate: true,
      timeZones: ['Local'],
      speedSlider: false,
      speedSliderMultiple: [1, 2, 3, 5, 10],
      speedMultiple: 5

};

var icon = L.icon({
    iconUrl: 'img/running.png',
    iconSize: [22, 22],
    iconAnchor: [5, 25]
});



function loadJSON(callback) {   

    var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
    xobj.open('GET', 'data/db.json', true); // Replace 'my_data' with the path to your file
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            callback(xobj.responseText);
          }
    };
    xobj.send(null);  
 }


 var actual_JSON = [];

 loadJSON(function(response) {
    // Parse JSON string into object
    actual_JSON = JSON.parse(response);
   });

setTimeout(function() {
    var playBackPath = []
actual_JSON.forEach(function(path) {
    if (path.id) {
        playBackPath.push([path.position.y, path.position.x, path.speed]);
    }
})


     var startDate = new Date();
startDate.setUTCHours(0, 0, 0, 0);

var geoJsonFeature = {
    type: 'FeatureCollection',
    features: [
      {
        type: 'Feature',
        properties: {
          time: actual_JSON[0],
          coordTimes: actual_JSON
        },
        geometry: {
          type: 'LineString',
          coordinates: playBackPath
        }
      }
    ]
  };

  var customLayer123 = L.geoJson(geoJsonFeature, {
    pointToLayer: function (feature, latLng) {
      if (feature.properties.hasOwnProperty('last')) {
        return new L.Marker(latLng, {
            icon: icon
        });
      }
      return L.circleMarker(latLng);
    }
  });



var customLayer = L.geoJson(null, {
    pointToLayer: function (feature, latLng) {
        if (feature.properties.hasOwnProperty('last')) {
            return new L.Marker(latLng, {
                icon: icon
            });
        }
        return L.circleMarker(latLng);
    }
});

var gpxLayer = omnivore.gpx('data/running_mallorca.gpx', null, customLayer).on('ready', function() {
    map.fitBounds(gpxLayer.getBounds(), {
        paddingBottomRight: [40, 40]
    });
});



  


  var gpxTimeLayer = L.timeDimension.layer.geoJson(customLayer123, {
    updateTimeDimension: true,
    addlastPoint: true,
    waitForReady: true
  });

/* 
var gpxTimeLayer = L.timeDimension.layer.geoJson(gpxLayer, {
    updateTimeDimension: true,
    addlastPoint: true,
    waitForReady: true
}); */

/* var kmlLayer = omnivore.kml('data/easy_currents_track.kml');
var kmlTimeLayer = L.timeDimension.layer.geoJson(kmlLayer, {
    updateTimeDimension: true,
    addlastPoint: true,
    waitForReady: true
}); */

/* 
var overlayMaps = {
    "GPX Layer": gpxTimeLayer
};
var baseLayers = getCommonBaseLayers(map); 
L.control.layers(baseLayers, overlayMaps).addTo(map);
 */

var timeDimensionControl = new L.Control.TimeDimension(timeDimensionControlOptions);
map.addControl(timeDimensionControl);

/* debugger; */
gpxTimeLayer.addTo(map);
}, 1000)


  
